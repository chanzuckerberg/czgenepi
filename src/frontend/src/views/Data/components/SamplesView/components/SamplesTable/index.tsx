import {
  ColumnDef,
  flexRender,
  getCoreRowModel,
  getSortedRowModel,
  RowSelectionState,
  useReactTable,
} from "@tanstack/react-table";
import {
  CellComponent,
  Icon,
  InputCheckbox,
  Table,
  TableHeader,
  TableRow,
} from "czifui";
import { map } from "lodash";
import { useEffect, useState } from "react";
import { IdMap } from "src/common/utils/dataTransforms";
import { datetimeWithTzToLocalDate } from "src/common/utils/timeUtils";
import { LineageTooltip } from "../../../LineageTooltip";
import { DefaultCell } from "./components/DefaultCell";
import { SortableHeader } from "./components/SortableHeader";
import { StyledCellBasic, StyledPrivateId } from "./style";

interface Props {
  data: IdMap<Sample> | undefined;
  isLoading: boolean;
  setCheckedSamples(samples: Sample[]): void;
}

const columns: ColumnDef<Sample, any>[] = [
  {
    id: "select",
    size: 50,
    header: ({ table }) => {
      const {
        getIsAllRowsSelected,
        getIsSomeRowsSelected,
        getToggleAllRowsSelectedHandler,
      } = table;
      const isChecked = getIsAllRowsSelected();
      const isIndeterminate = getIsSomeRowsSelected();
      const checkboxStage = isChecked
        ? "checked"
        : isIndeterminate
        ? "indeterminate"
        : "unchecked";

      const onChange = getToggleAllRowsSelectedHandler();

      return (
        <CellComponent>
          <InputCheckbox stage={checkboxStage} onChange={onChange} />
        </CellComponent>
      );
    },
    cell: ({ row }) => {
      const { getIsSelected, getToggleSelectedHandler } = row;

      const checkboxStage = getIsSelected() ? "checked" : "unchecked";
      const onChange = getToggleSelectedHandler();

      return (
        <CellComponent>
          <InputCheckbox stage={checkboxStage} onChange={onChange} />
        </CellComponent>
      );
    },
  },
  {
    id: "privateId",
    accessorKey: "privateId",
    minSize: 350,
    header: ({ header }) => (
      <SortableHeader
        header={header}
        tooltipStrings={{
          boldText: "Private ID",
          regularText:
            "User-provided private ID. Only users in your Group can see it.",
        }}
      >
        Private ID
      </SortableHeader>
    ),
    cell: ({ getValue, row }) => {
      const { uploadedBy, private: isPrivate } = row?.original;
      const uploader = uploadedBy?.name;

      return (
        <StyledPrivateId
          primaryText={getValue()}
          secondaryText={uploader}
          shouldTextWrap
          primaryTextWrapLineCount={1}
          icon={
            <Icon
              sdsIcon={isPrivate ? "flaskPrivate" : "flaskPublic"}
              sdsSize="xl"
              sdsType="static"
            />
          }
          tooltipProps={{
            sdsStyle: "light",
            arrow: false,
          }}
        />
      );
    },
    enableSorting: true,
  },
  {
    id: "publicId",
    accessorKey: "publicId",
    header: ({ header }) => (
      <SortableHeader
        header={header}
        tooltipStrings={{
          boldText: "Public ID",
          regularText:
            "This is your GISAID ID or public ID generated by CZ Gen Epi.",
        }}
      >
        Public ID
      </SortableHeader>
    ),
    cell: DefaultCell,
    enableSorting: true,
  },
  {
    id: "uploadDate",
    accessorKey: "uploadDate",
    header: ({ header }) => (
      <SortableHeader
        header={header}
        tooltipStrings={{
          boldText: "Upload Date",
          regularText: "Date on which the sample was uploaded to CZ Gen Epi.",
        }}
      >
        Upload Date
      </SortableHeader>
    ),
    cell: ({ getValue }) => (
      <StyledCellBasic
        shouldTextWrap
        primaryText={datetimeWithTzToLocalDate(getValue())}
        primaryTextWrapLineCount={2}
        shouldShowTooltipOnHover={false}
      />
    ),
  },
  {
    id: "collectionDate",
    accessorKey: "collectionDate",
    header: ({ header }) => (
      <SortableHeader
        header={header}
        tooltipStrings={{
          boldText: "Collection Date",
          regularText:
            "User-provided date on which the sample was collected from an individual or an environment.",
        }}
      >
        Collection Date
      </SortableHeader>
    ),
    cell: DefaultCell,
    enableSorting: true,
  },
  {
    id: "lineage",
    accessorKey: "lineage",
    header: ({ header }) => (
      <SortableHeader
        header={header}
        tooltipStrings={{
          boldText: "Lineage",
          link: {
            href: "https://cov-lineages.org/pangolin.html",
            linkText: "Learn more.",
          },
          regularText:
            "A lineage is a named group of related sequences. A few lineages have been associated with changes in the epidemiological or biological characteristics of the virus. We continually update these lineages based on the evolving Pangolin designations. Lineages determined by Pangolin.",
        }}
      >
        Lineage
      </SortableHeader>
    ),
    cell: ({ getValue }) => {
      const { lineage } = getValue();
      const CellContent = (
        <StyledCellBasic
          shouldTextWrap
          primaryText={lineage ?? "Not Yet Processed"}
          primaryTextWrapLineCount={2}
          shouldShowTooltipOnHover={false}
        />
      );

      return lineage ? (
        <LineageTooltip lineage={lineage}>{CellContent}</LineageTooltip>
      ) : (
        CellContent
      );
    },
    enableSorting: true,
  },
  {
    id: "collectionLocation",
    accessorKey: "collectionLocation",
    header: ({ header }) => (
      <SortableHeader
        header={header}
        tooltipStrings={{
          boldText: "Collection Location",
          regularText:
            "User-provided geographic location where the sample was collected (at the county level or above).",
        }}
      >
        Collection Location
      </SortableHeader>
    ),
    cell: ({ getValue }) => (
      <StyledCellBasic
        shouldTextWrap
        primaryText={getValue().location}
        primaryTextWrapLineCount={2}
        shouldShowTooltipOnHover={false}
      />
    ),
    enableSorting: true,
  },
  {
    id: "sequencingDate",
    accessorKey: "sequencingDate",
    header: ({ header }) => (
      <SortableHeader
        header={header}
        tooltipStrings={{
          boldText: "Sequencing Date",
          regularText: "User-provided date on which the sample was sequenced.",
        }}
      >
        Sequencing Date
      </SortableHeader>
    ),
    cell: DefaultCell,
  },
  {
    id: "gisaid",
    accessorKey: "gisaid",
    header: ({ header }) => (
      <SortableHeader
        header={header}
        tooltipStrings={{
          boldText: "GISAID Status",
          regularText:
            "Whether your sample has been Not Yet Submitted, Submitted, Accepted (with GISAID accession), Rejected, or Not Eligible (marked private).",
        }}
      >
        GISAID
      </SortableHeader>
    ),
    cell: ({ getValue }) => {
      const { gisaid_id, status } = getValue();
      return (
        <StyledCellBasic
          primaryText={status}
          secondaryText={gisaid_id}
          shouldShowTooltipOnHover={false}
        />
      );
    },
    enableSorting: true,
  },
];

const SamplesTable = ({
  data,
  isLoading,
  setCheckedSamples,
}: Props): JSX.Element => {
  const [samples, setSamples] = useState<Sample[]>([]);
  const [rowSelection, setRowSelection] = useState<RowSelectionState>({});

  useEffect(() => {
    if (!data) return;

    const newSamples = map(data, (v) => v);
    setSamples(newSamples);
  }, [data]);

  const table = useReactTable({
    data: samples,
    defaultColumn: {
      minSize: 50,
    },
    columns,
    enableMultiRowSelection: true,
    getCoreRowModel: getCoreRowModel(),
    getSortedRowModel: getSortedRowModel(),
    state: {
      rowSelection,
    },
    onRowSelectionChange: setRowSelection,
  });

  useEffect(() => {
    // for each selected row in the table, map the react-table internal row to the data (Sample)
    // originally passed into the row
    const newCheckedSamples = table
      .getSelectedRowModel()
      .rows.map((r) => r.original);

    setCheckedSamples(newCheckedSamples);
  }, [rowSelection]);

  if (isLoading) {
    return <div>Loading ...</div>;
  }

  return (
    <Table>
      <TableHeader>
        {table
          .getLeafHeaders()
          .map((header) =>
            flexRender(header.column.columnDef.header, header.getContext())
          )}
      </TableHeader>
      <tbody>
        {table.getRowModel().rows.map((row) => (
          <TableRow key={row.id}>
            {row
              .getVisibleCells()
              .map((cell) =>
                flexRender(cell.column.columnDef.cell, cell.getContext())
              )}
          </TableRow>
        ))}
      </tbody>
    </Table>
  );
};

export { SamplesTable };
